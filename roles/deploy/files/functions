#! /bin/bash

# Functions to print keyboard mapping
if [ -f keyboards ]; then
  source keyboards
fi

# repeat n times command
function repeat()
{
  local i max
  max=$1; shift;
  for ((i=1; i <= max ; i++)); do
    eval "$@";
  done
}

# Find a file with a pattern in name - dans le rep local:
function ff() { find . -type f -iname '*'$*'*' -ls ; }


# change le titre de la fenÃªtre de la console
t () {
  echo -ne "\\e]2;$1\\a"
}


function fn_to_lowercase()       # Correct filenames to lowercase
{
  if [ "$#" = 0 ]
  then
    echo "Usage: fn_to_lowercase [filenames...]"
    return 0
  fi

  for arg in "$@"; do
    filename=`basename "$arg"`
    dirname=`dirname "$arg"`
    oldname=`echo "$filename" | sed -e "s/ /\\\\ /"`
    newname=`echo "$filename" | tr A-Z a-z`
    if [ ! -e "$dirname/$oldname" ];
    then
      echo "$dirname/$oldname does not exists."
    elif [ "$oldname" = "$newname" ]
    then
      echo "$dirname/$oldname needs no change, skipping..."
    elif [ -e "$dirname/$newname" ]
    then
      echo "$dirname/$newname exists, skipping..."
    else
      mv "$dirname/$oldname" "$dirname/$newname"
      echo "$dirname/$oldname => $dirname/$newname"
    fi
  done
}


function fn_no_spaces()       # Correct spaces in filenames
{
  if [ "$#" = 0 ]
  then
    echo "Usage: fn_no_spaces [filenames...]"
    return 0
  fi

  for arg in "$@"
  do
    filename=`basename "$arg"`
    dirname=`dirname "$arg"`
    oldname=`echo "$filename" | sed -e "s/ /\\\\ /"`
    newname=`echo "$filename" | sed -e : -e s/\ /_/ -e s/%20/_/ -e s/%28/[/ -e s/%29/]/ -e s/%5B/[/ -e s/
    %5D/]/ -e t`
    if [ ! -e "$dirname/$oldname" ];
    then
      echo "$dirname/$oldname does not exists."
    elif [ "$oldname" = "$newname" ]
    then
      echo "$dirname/$oldname needs no change, skipping..."
    elif [ -e "$dirname/$newname" ]
    then
      echo "$dirname/$newname exists, skipping..."
    else
      mv "$dirname/$oldname" "$dirname/$newname"
      echo "$dirname/$oldname => $dirname/$newname"
    fi
  done
}

# gojo - tries to unarchive anything thrown at it
gojo() {
  ##### Probably done more robustly with file(1) but not as easily
  local FILENAME="${1}"
  local FILEEXTENSION=`echo ${1} | cut -d. -f2-`
  case "$FILEEXTENSION" in
    tar)
      tar xvf "$FILENAME";;
    tar.gz)
      tar xzvf "$FILENAME";;
    tgz)
      tar xzvf "$FILENAME";;
    gz)
      gunzip "$FILENAME";;
    tbz)
      tar xjvf "$FILENAME";;
    tbz2)
      tar xjvf "$FILENAME";;
    tar.bz2)
      tar xjvf "$FILENAME";;
    tar.bz)
      tar xjvf "$FILENAME";;
    bz2)
      bunzip2 "$FILENAME";;
    tar.Z)
      tar xZvf "$FILENAME";;
    Z)
      uncompress "$FILENAME";;
    zip)
      unzip "$FILENAME";;
    rar)
      unrar x "$FILENAME";;
  esac
}

# Pour le fun
bonjour (){
  local rnd
  rnd=$[RANDOM%4]

  case $rnd in
    0 )
      echo "Bonjour MaÃ®tre vÃ©nÃ©rÃ©"
      ;;
    1 )
      echo "Quel plaisir de vous revoir Grand MaÃ®tre!"
      ;;
    2 )
      echo "MaÃ®tre tout puissant, je vous salue"
      ;;
    3 )
      echo "Mon MaÃ®tre, je suis Ã  vos ordres"
      ;;
  esac
}

#RÃ©cupÃ¨re l'adresse IP publique
pub(){
  local ip_site

  ip_site="http://curlmyip.com"

  echo "Votre ip publique est:"

  if [ `which curl` ]; then
    echo -ne "$BYellow \t"; curl $ip_site; echo -e "${Color_Off}"
  elif [ `which wget` ]; then
    echo -ne "$BYellow \t"; wget -O - -q $ip_site; echo -e "${Color_Off}"
  elif [ `which lynx` ]; then
    echo -ne "$BYellow \t"; lynx --dump $ip_site; echo -e "${Color_Off}"
  else
    echo "Impossible de trouver un programme pour rÃ©cupÃ©rer une page web"
    exit 1
  fi
}


#RÃ©cupÃ¨re l'adresse IP (privÃ©e)
function priv()
{
  local ip lo eth wlan

  ip=$(echo $BYellow | sed 's/\\e//g')
  lo=$(echo $BCyan | sed 's/\\e//g')
  eth=$(echo $BRed | sed 's/\\e//g')
  wlan=$(echo $BPurple | sed 's/\\e//g')

  echo "Vos ip privÃ©es sont:"

  if [ `which ip` ]; then
    ip a | grep "inet " | egrep "(eth[^ ]+|wlan[^ ]|lo)" | awk '
    {print $NF "/" $2}
    ' | awk -F/ '
    $1 == "lo" {print "\t '$lo'" $1 ": '$ip'" $2}
    $1 ~ "eth" {print "\t '$eth'" $1 ": '$ip'" $2}
    $1 ~ "wlan" {print "\t '$wlan'" $1 ": '$ip'" $2}
    '; echo -ne $Color_Off

  elif [ -f /sbin/ifconfig ]; then
    /sbin/ifconfig | egrep -B1 "inet add?r" | awk '
    $1 == "inet" { print $2 }
    $2 == "Link" { printf "%s:" , $1 }
    ' | awk -F: '
    $1 == "lo" {print "\t '$lo'" $1 ": '$ip'" $3}
    $1 ~ "eth" {print "\t '$eth'" $1 ": '$ip'" $3}
    $1 ~ "wlan" {print "\t '$wlan'" $1 ": '$ip'" $3}
    '; echo -ne $Color_Off
  else
    echo 'Impossible de trouver un programme pour rÃ©cupÃ©rer les adresses des interfaces'
    exit 1
  fi
}

function add-backports(){
sudo echo "deb http://http.debian.net/debian wheezy-backports main" >> /etc/apt/sources.list;
apt-get update;
}

function find-obsolete() {
  local pid cmd file

  for pid in $(\grep '(deleted)' /proc/*/maps | \grep -v '/dev/zero' | cut -d/ -f 3 | sort -un); do
    cmd=$(ps -o comm -p $pid | tail -n 1)
    for file in $(\grep '(deleted)' /proc/$pid/maps |grep -v '/dev/zero' | awk '{print $6}' | sort -u); do
      echo "$pid $cmd $file"
    done
  done | column -t

}

genpasswd() {
  local l=$1
    [ "$l" == "" ] && l=20
    tr -dc A-Za-z0-9_ < /dev/urandom | head -c ${l} | xargs
}

running_shell() {
  basename -- "${0#-}" | grep $1 >/dev/null
}
